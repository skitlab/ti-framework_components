/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
/*
 *  ======== alg_malloc.c ========
 *  This module implements an algorithm memory management "policy" in which
 *  no memory is shared among algorithm objects.  Memory is, however
 *  reclaimed when objects are deleted.
 *
 *  preemption      sharing             object deletion
 *  ----------      -------             ---------------
 *  yes(*)          none                yes
 *
 *  Note 1: this module uses run-time support functions malloc() and free()
 *  to allocate and free memory.  Since these functions are *not* reentrant,
 *  either all object creation and deletion must be performed by a single
 *  thread or reentrant versions or these functions must be created.
 */

#include <xdc/std.h>


#include <ti/xdais/ialg.h>

#include <stdlib.h>     /* malloc/free declarations */
#include <string.h>     /* memset declaration */

#ifdef __GNUC__
#include <malloc.h> /* memalign declaration is here for Linux */
#endif

#include "alg.h"
#include "_alg.h"
#include <ti/sdo/utils/trace/gt.h>

/*
 * Mask to enable GT tracing
 */
GT_Mask ti_sdo_ce_osal_alg_GTMask;

/*
 *  Base ID for semaphores in this module. This is auto-generated by
 *  Global.xdt.
 */
/*  extern UInt32 ti_sdo_ce_osal_ALG_ipcKey;*/

Bool _ALG_allocMemory(IALG_MemRec memTab[], Int n);
Void _ALG_freeMemory(IALG_MemRec memTab[], Int n);

static Int curInit = 0;     /* module init counter */

/*
 *  ======== ALG_activate ========
 */
Void ALG_activate(Int groupId, ALG_Handle alg)
{
    /* acquire lock */
    /* TODO:M what if groupId is out of range?  At least drop some trace? */
    if ((0 <= groupId) && (groupId < _ALG_NUMGROUPS)) {
/*          SemMP_pend(_ALG_sems[groupId], SemMP_FOREVER);*/
    }

    /* restore all persistant shared memory */
    /* nothing to do since memory allocation never shares any data */

    /* do app specific initialization of scratch memory */
    if (alg->fxns->algActivate != NULL) {
        alg->fxns->algActivate(alg);
    }
}

/*
 *  ======== ALG_deactivate ========
 */
Void ALG_deactivate(Int groupId, ALG_Handle alg)
{
    /* do app specific store of persistent data */
    if (alg->fxns->algDeactivate != NULL) {
        alg->fxns->algDeactivate(alg);
    }

    /* save all persistant shared memory */
    /* nothing to do since memory allocation never shares any data */

    /* release lock */
    /* TODO:M what if groupId is out of range?  At least drop some trace? */
    if ((0 <= groupId) && (groupId < _ALG_NUMGROUPS)) {
/*          SemMP_post(_ALG_sems[groupId]);*/
    }
}

/*
 *  ======== ALG_exit ========
 */
Void ALG_exit(Void)
{
    Int i;

    if (--curInit == 0) {
        /* De-initialize semaphores */
        for (i = 0; i < _ALG_NUMGROUPS; i++) {
/*              SemMP_delete(_ALG_sems[i]);*/
/*              _ALG_sems[i] = NULL;*/
        }
    }
}

/*
 *  ======== ALG_init ========
 */
Void ALG_init(Void)
{
    Int i;

    if (curInit++ == 0) {

        GT_init();

        GT_create(&ti_sdo_ce_osal_alg_GTMask, ALG_GTNAME);

        GT_0trace(ti_sdo_ce_osal_alg_GTMask, GT_ENTER, "ALG_init> Enter\n");

        /* Initialize semaphores with count 1 */
        for (i = 0; i < _ALG_NUMGROUPS; i++) {
/*              _ALG_sems[i] = SemMP_create((Int)ti_sdo_ce_osal_ALG_ipcKey + i, 1);*/
        }

/*          Global_atexit((Fxn)ALG_exit);*/
    }
    else {
        GT_0trace(ti_sdo_ce_osal_alg_GTMask, GT_2CLASS, "ALG_init> Enter\n");
    }

    GT_0trace(ti_sdo_ce_osal_alg_GTMask, GT_ENTER, "ALG_init> Exit\n");
}


extern Bool ti_sdo_ce_osal_alg_ALG_useCache;
extern Bool ti_sdo_ce_osal_alg_ALG_useHeap;


/*
 *  ======== _ALG_allocMemory ========
 */
Bool _ALG_allocMemory(IALG_MemRec memTab[], Int n)
{
    Int i;

    for (i = 0; i < n; i++) {
        memTab[i].base = malloc(memTab[i].size);

        if (memTab[i].base == NULL) {
            _ALG_freeMemory(memTab, i);
            return (FALSE);
        }
        memset(memTab[i].base, 0, memTab[i].size);
    }

    return (TRUE);
}

/*
 *  ======== _ALG_freeMemory ========
 */
Void _ALG_freeMemory(IALG_MemRec memTab[], Int n)
{
    Int i;

    for (i = 0; i < n; i++) {
        if (memTab[i].base != NULL) {

            free(memTab[i].base);
        }
    }
}
/*
 *  @(#) ti.sdo.fc.rman.examples; 1, 0, 0,4; 2-22-2012 18:07:14; /db/atree/library/trees/fc/fc-q07/src/ xlibrary

 */

