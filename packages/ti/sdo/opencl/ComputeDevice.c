/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */


/*
 *  ======== ComputeDevice.c ========
 *
 */

/* this define must precede inclusion of any xdc header file */
#define Registry_CURDESC ComputeDevice__Desc
#define MODULE_NAME "ComputeDevice"

#include <string.h>

/* xdctools header files */
#include <xdc/std.h>
#include <xdc/runtime/Assert.h>
#include <xdc/runtime/Diags.h>
#include <xdc/runtime/Error.h>
#include <xdc/runtime/Log.h>
#include <xdc/runtime/Memory.h>
#include <xdc/runtime/Registry.h>

/* package header files */
#include <ti/ipc/MultiProc.h>
// #include <ti/sdo/opencl/ti_cl.h>
#include <ti/sdo/rcm/RcmServer.h>

#include <ti/xdais/ialg.h>

/* local header files */
#include "ComputeDevice.h"
// #include "Hello.h"
// #include "Tsr.h"

typedef struct {
    Fxn     fxnAddr;
    Int     numArgs;
} KnlDesc;

static Int32 ComputeDevice_opencl_sig(UInt32 dataSize, UInt32 *data);
static Int32 ComputeDevice_opencl_skel(UInt32 dataSize, UInt32 *data);

/* generated by ComputeDevice.xdt */
extern Int ti_sdo_opencl_ComputeDevice_numUnits;
extern ComputeDevice_Unit ti_sdo_opencl_ComputeDevice_units[];

/* private data */
static Int          curInit = 0;
Registry_Desc       Registry_CURDESC; /* module diags mask */
static KnlDesc *    knlDbElem = NULL;
static Int          knlDbLength = 0;


/* RcmServer static function table */
static RcmServer_FxnDesc serverFxnAry[] = {
    { "OpenCL_sig",     ComputeDevice_opencl_sig        },
    { "OpenCL_skel",    ComputeDevice_opencl_skel       }
};

#define serverFxnAryLen (sizeof serverFxnAry / sizeof serverFxnAry[0])

static const RcmServer_FxnDescAry Server_fxnTab = {
    serverFxnAryLen,
    serverFxnAry
};

static RcmServer_Handle rcmServerH = NULL;


/*
 *  ======== ComputeDevice_init ========
 */
Void ComputeDevice_init(Void)
{
    Registry_Result         result;
    ComputeDevice_Unit *    unit;
    Int i, j;
    KnlDesc *knl;


    if (curInit++ != 0) {
        return;  /* already initialized */
    }

    /* register with xdc.runtime to get a diags mask */
    result = Registry_addModule(&Registry_CURDESC, MODULE_NAME);
    Assert_isTrue(result == Registry_SUCCESS, (Assert_Id)NULL);

    /* initialize modules */
    RcmServer_init();

    /* turn on some trace for debug support */
//  Diags_setMask("ti.sdo.rcm.RcmServer+F");
//  Diags_setMask("Tsr+EXF");

    /* call init functions for configured OpenCL units */
    for (i = 0; i < ti_sdo_opencl_ComputeDevice_numUnits; i++) {
        unit = &ti_sdo_opencl_ComputeDevice_units[i];
        if (unit->initFxn != NULL) {
            (unit->initFxn)();
        }
    }

    /* collect all configured OpenCL kernel units */
    for (i = 0; i < ti_sdo_opencl_ComputeDevice_numUnits; i++) {
        unit = &ti_sdo_opencl_ComputeDevice_units[i];
        knlDbLength += unit->numFxns;
    }

    knlDbElem = (KnlDesc *)Memory_calloc(NULL, knlDbLength * sizeof(KnlDesc),
        sizeof(Int), NULL);

    knl = knlDbElem;
    for (i = 0; i < ti_sdo_opencl_ComputeDevice_numUnits; i++) {
        unit = &ti_sdo_opencl_ComputeDevice_units[i];
        for (j = 0; j < unit->numFxns; j++) {
            knl->fxnAddr = (unit->fxnTab[j]).addr;
            knl->numArgs = (unit->fxnTab[j]).numArgs;
            knl++;
        }
    }

}


/*
 *  ======== ComputeDevice_exit ========
 */
Void ComputeDevice_exit(Void)
{
//  Registry_Result result;
    ComputeDevice_Unit *    unit;
    Int i;


    if (curInit-- != 1) {
        return;  /* object still being used */
    }

    /* call exit functions for configured OpenCL units */
    for (i = 0; i < ti_sdo_opencl_ComputeDevice_numUnits; i++) {
        unit = &ti_sdo_opencl_ComputeDevice_units[i];
        if (unit->exitFxn != NULL) {
            (unit->exitFxn)();
        }
    }

    Memory_free(NULL, knlDbElem, knlDbLength * sizeof(KnlDesc));

    /* finalize modules */
//  Tsr_exit();
    RcmServer_exit();

    /* unregister from xdc.runtime */
//  result = Registry_removeModule(MODULE_NAME);
//  Assert_isTrue(result == Registry_SUCCESS, (Assert_Id)NULL);
}


/*
 *  ======== ComputeDevice_start ========
 */
#define FXNN "ComputeDevice_start"
Int ComputeDevice_start(Ptr ptr)
{
    ComputeDevice_Cfg * cfg = (ComputeDevice_Cfg *)ptr;
    RcmServer_Params    rcmServerP;
    Int                 status = 0;


    Log_print0(Diags_ENTRY | Diags_INFO, "--> "FXNN":");

    /* initialize RcmServer create params */
    RcmServer_Params_init(&rcmServerP);
    rcmServerP.fxns.length = Server_fxnTab.length;
    rcmServerP.fxns.elem = Server_fxnTab.elem;

    /* create the RcmServer instance */
    status = RcmServer_create(cfg->rcmServerName, &rcmServerP, &rcmServerH);

    if (status < 0) {
        Log_error1(FXNN": RcmServer_create() returned error %d", (IArg)status);
        goto leave;
    }

    /* start the server */
    RcmServer_start(rcmServerH);

leave:
    Log_print1(Diags_EXIT, "<-- "FXNN": %d", (IArg)status);
    return(status);
}
#undef FXNN


/*
 *  ======== ComputeDevice_stop ========
 */
#define FXNN "ComputeDevice_stop"
Int ComputeDevice_stop(Ptr ctx)
{
    Int status = 0;


    Log_print0(Diags_ENTRY | Diags_INFO, "--> "FXNN":");

    /* delete RcmServer instance */
    status = RcmServer_delete(&rcmServerH);

    if (status < 0) {
        Log_error1(FXNN": RcmServer_delete() returned error %d", (IArg)status);
        status = -1;
        goto leave;
    }

leave:
    Log_print1(Diags_EXIT, "<-- "FXNN": %d", (IArg)status);
    return(status);
}
#undef FXNN


/*
 *  ======== ComputeDevice_persistentAllocFxn ========
 */
Bool ComputeDevice_persistentAllocFxn(IALG_MemRec *memTab, Int numRecs)
{
    Int         i;
    Bool        status = TRUE;
    Error_Block eb;


    Error_init(&eb);

    for (i = 0; i < numRecs; i++) {
        if (memTab[i].attrs != IALG_PERSIST) {
            return(FALSE);
        }
        memTab[i].base = NULL;
    }

    for (i = 0; i < numRecs; i++) {
        memTab[i].base =
            Memory_calloc(NULL, memTab[i].size, memTab[i].alignment, &eb);

        if (Error_check(&eb)) {
            status = FALSE;
            break;
        }
    }

    if (status == FALSE) {
        for (; i >= 0; i--) {
            if (memTab[i].base != NULL) {
                Memory_free(NULL, memTab[i].base, memTab[i].size);
                memTab[i].base = NULL;
            }
        }
    }

    return (status);
}


/*
 *  ======== ComputeDevice_persistentFreeFxn ========
 */
Void ComputeDevice_persistentFreeFxn(IALG_MemRec *memTab, Int numRecs)
{
    Int i;

    for (i = 0; i < numRecs; i++) {
        Memory_free(NULL, memTab[i].base, memTab[i].size);
        memTab[i].base = NULL;
    }
}


/*
 *  ======== ComputeDevice_opencl_sig ========
 *  out data[0]     Int         status
 *  out data[1]     Int         opencl function index
 *  out data[2]     Int         opencl function argument count
 *  in  data[3]     Char[]      opencl kernel name
 */
Int32 ComputeDevice_opencl_sig(UInt32 dataSize, UInt32 *data)
{
    ComputeDevice_Unit *    unit;
    String                  name;
    Int                     knlIdx;
    Int                     i, j;
    Int                     status = 0;


    /* unmarshal OpenCL kernel name */
    name = (String)&data[3];

    /* map the kernel name to the local database index */
    knlIdx = 0;
    for (i = 0; i < ti_sdo_opencl_ComputeDevice_numUnits; i++) {
        unit = &ti_sdo_opencl_ComputeDevice_units[i];
        for (j = 0; j < unit->numFxns; j++) {
            if (strcmp((unit->fxnTab[j]).name, name) == 0) {
                goto done;
            }
            knlIdx++;
        }
    }

    if (knlIdx == knlDbLength) {
        knlIdx = -1;
        status = -1;
    }

    /* marshal the return values */
done:
    data[0] = (UInt32)(status);
    data[1] = (UInt32)(knlIdx);
    data[2] = (UInt32)(unit->fxnTab[j].numArgs);
    return(status);
}


/*
 *  ======== ComputeDevice_opencl_skel ========
 *
 *  out data[0]     Int         status
 *  in  data[1]     Int         openclIndex
 *  in  data[2]     UInt32      arg0 (optional)
 *  in  data[3]     UInt32      arg1 (optional)
 *  in  data[4]     UInt32      arg2 (optional)
 *  in  data[5]     UInt32      arg3 (optional)
 *  in  data[6]     UInt32      arg4 (optional)
 *  in  data[7]     UInt32      arg5 (optional)
 */
Int32 ComputeDevice_opencl_skel(UInt32 dataSize, UInt32 *data)
{
    Int         knlIdx;
    Int         knlNumArgs;
    UInt32      arg0, arg1, arg2, arg3, arg4, arg5;
    Void        (*knl1)(UInt32);
    Void        (*knl2)(UInt32, UInt32);
    Void        (*knl3)(UInt32, UInt32, UInt32);
    Void        (*knl4)(UInt32, UInt32, UInt32, UInt32);
    Void        (*knl5)(UInt32, UInt32, UInt32, UInt32, UInt32);
    Void        (*knl6)(UInt32, UInt32, UInt32, UInt32, UInt32, UInt32);
    Fxn         knlAddr;


    /* must have a non-zero size buffer */
    if (dataSize < (8 * sizeof(UInt32))) {
        data[0] = (UInt32)-1;
        return(-1);
    }

    /* unmarshal OpenCL kernel index */
    knlIdx = (Int)data[1];

    /* lookup kernel function address and argument count */
    knlAddr = knlDbElem[knlIdx].fxnAddr;
    knlNumArgs = knlDbElem[knlIdx].numArgs;

    /* invoke the OpenCL kernel */
    switch(knlNumArgs) {
        case 1:
            knl1 = (Void(*)(UInt32))knlAddr;
            arg0 = (UInt32)data[2];
            (knl1)(arg0);
            break;

        case 2:
            knl2 = (Void(*)(UInt32,UInt32))knlAddr;
            arg0 = (UInt32)data[2];
            arg1 = (UInt32)data[3];
            (knl2)(arg0, arg1);
            break;

        case 3:
            knl3 = (Void(*)(UInt32,UInt32,UInt32))knlAddr;
            arg0 = (UInt32)data[2];
            arg1 = (UInt32)data[3];
            arg2 = (UInt32)data[4];
            (knl3)(arg0, arg1, arg2);
            break;

        case 4:
            knl4 = (Void(*)(UInt32,UInt32,UInt32,UInt32))knlAddr;
            arg0 = (UInt32)data[2];
            arg1 = (UInt32)data[3];
            arg2 = (UInt32)data[4];
            arg3 = (UInt32)data[5];
            (knl4)(arg0, arg1, arg2, arg3);
            break;

        case 5:
            knl5 = (Void(*)(UInt32,UInt32,UInt32,UInt32,UInt32))knlAddr;
            arg0 = (UInt32)data[2];
            arg1 = (UInt32)data[3];
            arg2 = (UInt32)data[4];
            arg3 = (UInt32)data[5];
            arg4 = (UInt32)data[6];
            (knl5)(arg0, arg1, arg2, arg3, arg4);
            break;

        case 6:
            knl6 = (Void(*)(UInt32,UInt32,UInt32,UInt32,UInt32,UInt32))knlAddr;
            arg0 = (UInt32)data[2];
            arg1 = (UInt32)data[3];
            arg2 = (UInt32)data[4];
            arg3 = (UInt32)data[5];
            arg4 = (UInt32)data[6];
            arg5 = (UInt32)data[7];
            (knl6)(arg0, arg1, arg2, arg3, arg4, arg5);
            break;

        default:
            /* TODO */
            break;
    }

    /* marshal the return status */
    data[0] = 0;
    return(0);
}
/*
 *  @(#) ti.sdo.opencl; 1, 0, 0,4; 2-22-2012 18:09:27; /db/atree/library/trees/fc/fc-q07/src/ xlibrary

 */

